/*
 * Copyright (C) 2020-2022, IrineSistiana
 *
 * This file is part of mosdns.
 *
 * mosdns is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * mosdns is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 */

// Package rewrite is a mosdns plugin that combines the functionality of hosts and redirect.
// It can rewrite a domain query to a static IP address or resolve another domain and return its IP addresses directly, without a CNAME record.
// This plugin also provides a dynamic API to update rules in real-time.
package rewrite

import (
	"bufio"
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net"
	"net/http"
	"os"
	"path/filepath"
	"strings"
	"sync"
	"time"

	"github.com/IrineSistiana/mosdns/v5/coremain"
	"github.com/IrineSistiana/mosdns/v5/pkg/matcher/domain"
	"github.com/IrineSistiana/mosdns/v5/pkg/query_context"
	"github.com/IrineSistiana/mosdns/v5/plugin/executable/sequence"
	"github.com/go-chi/chi/v5"
	"github.com/miekg/dns"
)

const PluginType = "rewrite"
const defaultDNSTimeout = 5 * time.Second
const fixedTTL = 5 // TTL set to 5 seconds for all responses generated by this plugin.

func init() {
	coremain.RegNewPluginFunc(PluginType, Init, func() any { return new(Args) })
}

// rewriteTarget holds the parsed target of a rewrite rule.
type rewriteTarget struct {
	isIP   bool
	ip     net.IP
	domain string
}

// Args defines the configuration options for the rewrite plugin.
type Args struct {
	Files []string `yaml:"files"`
	Dns   string   `yaml:"dns"`
}

// Rewrite is the main struct for the plugin, holding its state and configuration.
type Rewrite struct {
	mu            sync.RWMutex // Protects access to matcher and rules
	matcher       *domain.MixMatcher[*rewriteTarget]
	dnsClient     *dns.Client
	dnsServerAddr string

	// Fields for API functionality
	ruleFile string
	rules    []string
}

// apiPayload is used for decoding JSON from the /post API endpoint.
type apiPayload struct {
	Values []string `json:"values"`
}

// Init initializes the plugin from the configuration.
func Init(bp *coremain.BP, args any) (any, error) {
	cfg := args.(*Args)
	if len(cfg.Files) == 0 {
		return nil, fmt.Errorf("at least one rule file must be specified in `files`")
	}

	// Prepare upstream DNS client
	dnsServerAddr, err := parseUpstreamAddr(cfg.Dns)
	if err != nil {
		return nil, fmt.Errorf("invalid upstream dns server: %w", err)
	}
	dnsClient := &dns.Client{
		Net:     "udp",
		Timeout: defaultDNSTimeout,
	}

	r := &Rewrite{
		matcher:       domain.NewMixMatcher[*rewriteTarget](),
		dnsClient:     dnsClient,
		dnsServerAddr: dnsServerAddr,
		ruleFile:      cfg.Files[0], // Use the first file for API operations
	}
	r.matcher.SetDefaultMatcher(domain.MatcherFull)

	// Load initial rules
	loadedRules, err := r.loadRulesFromFiles(cfg.Files)
	if err != nil {
		return nil, err
	}
	r.rules = loadedRules

	// Register API endpoints
	bp.RegAPI(r.api())

	return r, nil
}

// loadRulesFromFiles populates the matcher and raw rules list from file paths.
func (r *Rewrite) loadRulesFromFiles(files []string) ([]string, error) {
	var allRules []string
	newMatcher := domain.NewMixMatcher[*rewriteTarget]()
	newMatcher.SetDefaultMatcher(domain.MatcherFull)

	for i, file := range files {
		b, err := os.ReadFile(file)
		if err != nil {
			// Allow non-existent files on startup
			if os.IsNotExist(err) {
				continue
			}
			return nil, fmt.Errorf("failed to read file #%d %s, %w", i, file, err)
		}
		rules, err := loadRulesFromReader(bytes.NewReader(b), newMatcher)
		if err != nil {
			return nil, fmt.Errorf("failed to load rules from file #%d %s, %w", i, file, err)
		}
		allRules = append(allRules, rules...)
	}
	r.matcher = newMatcher
	return allRules, nil
}

// loadRulesFromReader is a helper that populates a given matcher from a reader.
func loadRulesFromReader(reader io.Reader, targetMatcher *domain.MixMatcher[*rewriteTarget]) ([]string, error) {
	var loadedRules []string
	scanner := bufio.NewScanner(reader)
	lineNum := 0
	for scanner.Scan() {
		lineNum++
		line := strings.TrimSpace(scanner.Text())
		if line == "" || strings.HasPrefix(line, "#") {
			continue
		}
		if err := domain.Load[*rewriteTarget](targetMatcher, line, parseRewriteTarget); err != nil {
			return nil, fmt.Errorf("error on line %d: %w", lineNum, err)
		}
		loadedRules = append(loadedRules, line)
	}
	return loadedRules, scanner.Err()
}

// parseRewriteTarget is the core parsing function for a single rule string.
func parseRewriteTarget(s string) (pattern string, result *rewriteTarget, err error) {
	fields := strings.Fields(s)
	if len(fields) != 2 {
		err = fmt.Errorf("rule must have 2 fields, but got %d", len(fields))
		return
	}
	pattern = fields[0]
	value := fields[1]

	ip := net.ParseIP(value)
	if ip != nil {
		result = &rewriteTarget{isIP: true, ip: ip}
	} else {
		if _, ok := dns.IsDomainName(value); !ok {
			err = fmt.Errorf("invalid domain name syntax: %s", value)
			return
		}
		result = &rewriteTarget{isIP: false, domain: dns.Fqdn(value)}
	}
	return
}

// Exec is the main entry point for processing a DNS query.
func (r *Rewrite) Exec(ctx context.Context, qCtx *query_context.Context, next sequence.ChainWalker) error {
	q := qCtx.Q()
	if len(q.Question) != 1 {
		return next.ExecNext(ctx, qCtx)
	}
	qName := q.Question[0].Name

	r.mu.RLock()
	matcher := r.matcher
	r.mu.RUnlock()

	target, ok := matcher.Match(qName)

	if !ok {
		return next.ExecNext(ctx, qCtx)
	}

	if target.isIP {
		r.handleIPRewrite(qCtx, target.ip)
	} else {
		r.handleDomainRewrite(ctx, qCtx, target.domain)
	}
	return nil
}

// handleIPRewrite builds a response for a static IP target with a fixed TTL.
func (r *Rewrite) handleIPRewrite(qCtx *query_context.Context, ip net.IP) {
	q := qCtx.Q()
	isV6 := ip.To4() == nil
	qType := q.Question[0].Qtype

	var rr dns.RR
	if isV6 && qType == dns.TypeAAAA {
		rr = &dns.AAAA{
			Hdr: dns.RR_Header{
				Name:   q.Question[0].Name,
				Rrtype: dns.TypeAAAA,
				Class:  dns.ClassINET,
				Ttl:    fixedTTL, // <-- MODIFIED: Set fixed TTL
			},
			AAAA: ip,
		}
	} else if !isV6 && qType == dns.TypeA {
		rr = &dns.A{
			Hdr: dns.RR_Header{
				Name:   q.Question[0].Name,
				Rrtype: dns.TypeA,
				Class:  dns.ClassINET,
				Ttl:    fixedTTL, // <-- MODIFIED: Set fixed TTL
			},
			A: ip,
		}
	} else {
		resp := new(dns.Msg).SetReply(q)
		qCtx.SetResponse(resp)
		return
	}

	resp := new(dns.Msg).SetReply(q)
	resp.Answer = []dns.RR{rr}
	qCtx.SetResponse(resp)
}

// handleDomainRewrite resolves the target domain and returns its IPs with a fixed TTL.
func (r *Rewrite) handleDomainRewrite(ctx context.Context, qCtx *query_context.Context, targetDomain string) {
	originalQuery := qCtx.Q()
	qType := originalQuery.Question[0].Qtype

	if qType != dns.TypeA && qType != dns.TypeAAAA {
		resp := new(dns.Msg).SetReply(originalQuery)
		qCtx.SetResponse(resp)
		return
	}

	upstreamQuery := new(dns.Msg)
	upstreamQuery.SetQuestion(targetDomain, qType)
	upstreamQuery.SetEdns0(4096, true)

	upstreamResp, _, err := r.dnsClient.ExchangeContext(ctx, upstreamQuery, r.dnsServerAddr)
	if err != nil || upstreamResp == nil || upstreamResp.Rcode != dns.RcodeSuccess {
		failResp := new(dns.Msg).SetRcode(originalQuery, dns.RcodeServerFailure)
		qCtx.SetResponse(failResp)
		return
	}

	finalResp := new(dns.Msg).SetReply(originalQuery)
	finalResp.Question = originalQuery.Question

	// <-- MODIFIED: Iterate over answers to set the fixed TTL
	for _, ans := range upstreamResp.Answer {
		ans.Header().Ttl = fixedTTL
		finalResp.Answer = append(finalResp.Answer, ans)
	}

	qCtx.SetResponse(finalResp)
}

// --- API Methods ---

func (r *Rewrite) api() *chi.Mux {
	router := chi.NewRouter()
	router.Get("/show", r.handleShow)
	router.Post("/post", r.handlePost)
	return router
}

func (r *Rewrite) handleShow(w http.ResponseWriter, req *http.Request) {
	r.mu.RLock()
	defer r.mu.RUnlock()
	w.Header().Set("Content-Type", "text/plain; charset=utf-8")
	w.Write([]byte(strings.Join(r.rules, "\n")))
}

func (r *Rewrite) handlePost(w http.ResponseWriter, req *http.Request) {
	var p apiPayload
	if err := json.NewDecoder(req.Body).Decode(&p); err != nil {
		http.Error(w, "invalid JSON payload", http.StatusBadRequest)
		return
	}

	if r.ruleFile == "" {
		http.Error(w, "no rule file configured, cannot post rules", http.StatusBadRequest)
		return
	}

	tmpMatcher := domain.NewMixMatcher[*rewriteTarget]()
	tmpMatcher.SetDefaultMatcher(domain.MatcherFull)

	tmpRules, err := loadRulesFromReader(strings.NewReader(strings.Join(p.Values, "\n")), tmpMatcher)
	if err != nil {
		http.Error(w, fmt.Sprintf("failed to parse new rules: %s", err), http.StatusBadRequest)
		return
	}

	r.mu.Lock()
	r.matcher = tmpMatcher
	r.rules = tmpRules
	r.mu.Unlock()

	if err := writeRulesToFile(r.ruleFile, r.rules); err != nil {
		http.Error(w, fmt.Sprintf("In-memory rules updated, but failed to write to file: %s", err), http.StatusInternalServerError)
		return
	}
	w.Header().Set("Content-Type", "text/plain; charset=utf-8")
	w.WriteHeader(http.StatusOK)
	fmt.Fprintf(w, "rewrite rules replaced with %d entries", len(r.rules))
}

// --- Utility Functions ---

func parseUpstreamAddr(addr string) (string, error) {
	if addr == "" {
		return "", fmt.Errorf("upstream dns server address cannot be empty")
	}
	host, port, err := net.SplitHostPort(addr)
	if err != nil {
		host = addr
		port = "53"
	}
	return net.JoinHostPort(host, port), nil
}

func writeRulesToFile(path string, rules []string) error {
	dir := filepath.Dir(path)
	tempFile, err := os.CreateTemp(dir, "rewrite-*.tmp")
	if err != nil {
		return fmt.Errorf("failed to create temporary file: %w", err)
	}
	defer os.Remove(tempFile.Name())

	writer := bufio.NewWriter(tempFile)
	if _, err := writer.WriteString(strings.Join(rules, "\n") + "\n"); err != nil {
		tempFile.Close()
		return fmt.Errorf("failed to write to temporary file: %w", err)
	}
	if err := writer.Flush(); err != nil {
		tempFile.Close()
		return fmt.Errorf("failed to flush temporary file: %w", err)
	}
	if err := tempFile.Close(); err != nil {
		return fmt.Errorf("failed to close temporary file: %w", err)
	}

	if err := os.Rename(tempFile.Name(), path); err != nil {
		return fmt.Errorf("failed to rename temporary file to final destination: %w", err)
	}

	return nil
}

// Interface guards
var _ sequence.RecursiveExecutable = (*Rewrite)(nil)
